{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"EmblaCarousel\", [], factory);else if (typeof exports === 'object') exports[\"EmblaCarousel\"] = factory();else root[\"EmblaCarousel\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function () {\n  return (\n    /******/\n    function (modules) {\n      // webpackBootstrap\n\n      /******/\n      // The module cache\n\n      /******/\n      var installedModules = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (installedModules[moduleId]) {\n          /******/\n          return installedModules[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = installedModules[moduleId] = {\n          /******/\n          i: moduleId,\n\n          /******/\n          l: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n        module.l = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /******/\n\n      /******/\n      // expose the modules object (__webpack_modules__)\n\n      /******/\n\n\n      __webpack_require__.m = modules;\n      /******/\n\n      /******/\n      // expose the module cache\n\n      /******/\n\n      __webpack_require__.c = installedModules;\n      /******/\n\n      /******/\n      // define getter function for harmony exports\n\n      /******/\n\n      __webpack_require__.d = function (exports, name, getter) {\n        /******/\n        if (!__webpack_require__.o(exports, name)) {\n          /******/\n          Object.defineProperty(exports, name, {\n            enumerable: true,\n            get: getter\n          });\n          /******/\n        }\n        /******/\n\n      };\n      /******/\n\n      /******/\n      // define __esModule on exports\n\n      /******/\n\n\n      __webpack_require__.r = function (exports) {\n        /******/\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n          /******/\n          Object.defineProperty(exports, Symbol.toStringTag, {\n            value: 'Module'\n          });\n          /******/\n        }\n        /******/\n\n\n        Object.defineProperty(exports, '__esModule', {\n          value: true\n        });\n        /******/\n      };\n      /******/\n\n      /******/\n      // create a fake namespace object\n\n      /******/\n      // mode & 1: value is a module id, require it\n\n      /******/\n      // mode & 2: merge all properties of value into the ns\n\n      /******/\n      // mode & 4: return value when already ns object\n\n      /******/\n      // mode & 8|1: behave like require\n\n      /******/\n\n\n      __webpack_require__.t = function (value, mode) {\n        /******/\n        if (mode & 1) value = __webpack_require__(value);\n        /******/\n\n        if (mode & 8) return value;\n        /******/\n\n        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n        /******/\n\n        var ns = Object.create(null);\n        /******/\n\n        __webpack_require__.r(ns);\n        /******/\n\n\n        Object.defineProperty(ns, 'default', {\n          enumerable: true,\n          value: value\n        });\n        /******/\n\n        if (mode & 2 && typeof value != 'string') for (var key in value) {\n          __webpack_require__.d(ns, key, function (key) {\n            return value[key];\n          }.bind(null, key));\n        }\n        /******/\n\n        return ns;\n        /******/\n      };\n      /******/\n\n      /******/\n      // getDefaultExport function for compatibility with non-harmony modules\n\n      /******/\n\n\n      __webpack_require__.n = function (module) {\n        /******/\n        var getter = module && module.__esModule ?\n        /******/\n        function getDefault() {\n          return module['default'];\n        } :\n        /******/\n        function getModuleExports() {\n          return module;\n        };\n        /******/\n\n        __webpack_require__.d(getter, 'a', getter);\n        /******/\n\n\n        return getter;\n        /******/\n      };\n      /******/\n\n      /******/\n      // Object.prototype.hasOwnProperty.call\n\n      /******/\n\n\n      __webpack_require__.o = function (object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property);\n      };\n      /******/\n\n      /******/\n      // __webpack_public_path__\n\n      /******/\n\n\n      __webpack_require__.p = \"\";\n      /******/\n\n      /******/\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(__webpack_require__.s = 6);\n      /******/\n    }(\n    /************************************************************************/\n\n    /******/\n    [\n    /* 0 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function Vector1D(value) {\n        var vector = value;\n\n        function get() {\n          return vector;\n        }\n\n        function set(n) {\n          vector = readNumber(n);\n          return self;\n        }\n\n        function add(n) {\n          vector += readNumber(n);\n          return self;\n        }\n\n        function subtract(n) {\n          vector -= readNumber(n);\n          return self;\n        }\n\n        function multiply(n) {\n          vector *= n;\n          return self;\n        }\n\n        function divide(n) {\n          vector /= n;\n          return self;\n        }\n\n        function normalize() {\n          if (vector !== 0) divide(vector);\n          return self;\n        }\n\n        function readNumber(n) {\n          return typeof n === 'number' ? n : n.get();\n        }\n\n        var self = {\n          add: add,\n          divide: divide,\n          get: get,\n          multiply: multiply,\n          normalize: normalize,\n          set: set,\n          subtract: subtract\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Vector1D = Vector1D;\n      /***/\n    },\n    /* 1 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function rectWidth(node) {\n        return node.getBoundingClientRect().width;\n      }\n\n      exports.rectWidth = rectWidth;\n\n      function map(value, iStart, iStop, oStart, oStop) {\n        return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n      }\n\n      exports.map = map;\n\n      function arrayFromCollection(nodeList) {\n        return Array.prototype.slice.call(nodeList);\n      }\n\n      exports.arrayFromCollection = arrayFromCollection;\n\n      function debounce(callback, time) {\n        var timeout = {\n          id: 0\n        };\n        return function () {\n          window.clearTimeout(timeout.id);\n          timeout.id = window.setTimeout(callback, time) || 0;\n        };\n      }\n\n      exports.debounce = debounce;\n\n      function roundToDecimals(decimalPoints) {\n        var pow = Math.pow(10, decimalPoints);\n        return function (n) {\n          return Math.round(n * pow) / pow;\n        };\n      }\n\n      exports.roundToDecimals = roundToDecimals;\n\n      function groupArray(array, size) {\n        var groups = [];\n\n        for (var i = 0; i < array.length; i += size) {\n          groups.push(array.slice(i, i + size));\n        }\n\n        return groups;\n      }\n\n      exports.groupArray = groupArray;\n\n      function arrayKeys(array) {\n        return Object.keys(array).map(Number);\n      }\n\n      exports.arrayKeys = arrayKeys;\n      /***/\n    },\n    /* 2 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function Limit(params) {\n        var min = params.min,\n            max = params.max;\n        var loopLimits = {\n          min: max,\n          max: min\n        };\n        var constrainLimits = {\n          min: min,\n          max: max\n        };\n\n        function reachedMin(n) {\n          return n < min;\n        }\n\n        function reachedMax(n) {\n          return n > max;\n        }\n\n        function reachedAny(n) {\n          return reachedMin(n) || reachedMax(n);\n        }\n\n        function reachedWhich(n) {\n          if (reachedMin(n)) return 'min';\n          if (reachedMax(n)) return 'max';\n          return '';\n        }\n\n        function loop(n) {\n          var which = reachedWhich(n);\n          return which ? loopLimits[which] : n;\n        }\n\n        function constrain(n) {\n          var which = reachedWhich(n);\n          return which ? constrainLimits[which] : n;\n        }\n\n        var self = {\n          constrain: constrain,\n          loop: loop,\n          max: max,\n          min: min,\n          reachedAny: reachedAny,\n          reachedMax: reachedMax,\n          reachedMin: reachedMin\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Limit = Limit;\n      /***/\n    },\n    /* 3 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function Counter(params) {\n        var start = params.start,\n            limit = params.limit,\n            loop = params.loop;\n        var min = limit.min,\n            max = limit.max;\n        var type = loop ? 'loop' : 'constrain';\n        var counter = withinLimit(start);\n\n        function get() {\n          return counter;\n        }\n\n        function set(n) {\n          counter = withinLimit(n);\n          return self;\n        }\n\n        function withinLimit(n) {\n          return limit[type](n);\n        }\n\n        function add(n) {\n          if (n !== 0) {\n            var sign = n / Math.abs(n);\n            set(get() + sign);\n            return add(n + sign * -1);\n          }\n\n          return self;\n        }\n\n        function clone() {\n          return Counter({\n            start: get(),\n            limit: limit,\n            loop: loop\n          });\n        }\n\n        var self = {\n          add: add,\n          clone: clone,\n          get: get,\n          max: max,\n          min: min,\n          set: set\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Counter = Counter;\n      /***/\n    },\n    /* 4 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function Direction(value) {\n        var direction = vector1d_1.Vector1D(normalize(value));\n        var get = direction.get;\n\n        function normalize(n) {\n          return n === 0 ? 0 : n / Math.abs(n);\n        }\n\n        function set(v) {\n          var d = normalize(v.get());\n          if (d !== 0) direction.set(d);\n          return self;\n        }\n\n        var self = {\n          get: get,\n          set: set\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Direction = Direction;\n      /***/\n    },\n    /* 5 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function EventStore() {\n        var listeners = [];\n\n        function add(node, type, handler) {\n          var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n          node.addEventListener(type, handler, options);\n          listeners.push(function () {\n            return node.removeEventListener(type, handler, options);\n          });\n          return self;\n        }\n\n        function removeAll() {\n          listeners.filter(function (remove) {\n            return remove();\n          });\n          listeners.length = 0;\n          return self;\n        }\n\n        var self = {\n          add: add,\n          removeAll: removeAll\n        };\n        return Object.freeze(self);\n      }\n\n      exports.EventStore = EventStore;\n      /***/\n    },\n    /* 6 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      module.exports = __webpack_require__(7);\n      /***/\n    },\n    /* 7 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      function _extends() {\n        _extends = Object.assign || function (target) {\n          for (var i = 1; i < arguments.length; i++) {\n            var source = arguments[i];\n\n            for (var key in source) {\n              if (Object.prototype.hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n              }\n            }\n          }\n\n          return target;\n        };\n\n        return _extends.apply(this, arguments);\n      }\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var engine_1 = __webpack_require__(8);\n\n      var eventDispatcher_1 = __webpack_require__(25);\n\n      var eventStore_1 = __webpack_require__(5);\n\n      var options_1 = __webpack_require__(26);\n\n      var utils_1 = __webpack_require__(1);\n\n      function EmblaCarousel(sliderRoot) {\n        var userOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var events = eventDispatcher_1.EventDispatcher();\n        var eventStore = eventStore_1.EventStore();\n        var debouncedResize = utils_1.debounce(resize, 500);\n        var changeOptions = reActivate;\n        var on = events.on,\n            off = events.off;\n        var engine;\n\n        var options = _extends({}, options_1.defaultOptions, userOptions);\n\n        var root;\n        var container;\n        var slides;\n        var activated = false;\n        var windowWidth = 0;\n        activate(options);\n\n        function storeElements() {\n          if (!sliderRoot) {\n            throw new Error('Missing root element 😢');\n          }\n\n          var selector = options.containerSelector;\n          var sliderContainer = sliderRoot.querySelector(selector);\n\n          if (!sliderContainer) {\n            throw new Error('Missing container element 😢');\n          }\n\n          root = sliderRoot;\n          container = sliderContainer;\n          slides = utils_1.arrayFromCollection(container.children);\n          activated = true;\n        }\n\n        function activate() {\n          var partialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          var isFirstInit = !activated;\n          windowWidth = window.innerWidth;\n          storeElements();\n          if (slides.length === 0) return;\n          options = _extends(options, partialOptions);\n          engine = engine_1.Engine(root, container, slides, options, events);\n          eventStore.add(window, 'resize', debouncedResize);\n          slides.forEach(slideFocusEvent);\n          engine.translate.to(engine.scrollBody.location);\n\n          if (options.loop && slides.length === 1) {\n            return activate({\n              loop: false\n            });\n          }\n\n          if (options.draggable) activateDragFeature();\n          if (options.loop) engine.slideLooper.loop(slides);\n\n          if (isFirstInit) {\n            events.on('select', toggleSelectedClass);\n            events.on('init', toggleSelectedClass);\n            setTimeout(function () {\n              return events.dispatch('init');\n            }, 0);\n          }\n        }\n\n        function activateDragFeature() {\n          var cl = root.classList;\n          var _options = options,\n              draggingClass = _options.draggingClass,\n              draggableClass = _options.draggableClass;\n          engine.dragHandler.addActivationEvents();\n          events.on('dragStart', function () {\n            return cl.add(draggingClass);\n          });\n          events.on('dragEnd', function () {\n            return cl.remove(draggingClass);\n          });\n          cl.add(draggableClass);\n        }\n\n        function toggleSelectedClass() {\n          var _engine = engine,\n              index = _engine.index,\n              indexPrevious = _engine.indexPrevious,\n              indexGroups = _engine.indexGroups;\n          var selected = options.selectedClass;\n          var previousGroup = indexGroups[indexPrevious.get()];\n          var currentGroup = indexGroups[index.get()];\n          previousGroup.forEach(function (i) {\n            return slides[i].classList.remove(selected);\n          });\n          currentGroup.forEach(function (i) {\n            return slides[i].classList.add(selected);\n          });\n        }\n\n        function slideFocusEvent(slide, index) {\n          var focus = function focus() {\n            var groupIndex = Math.floor(index / options.slidesToScroll);\n            var selectedGroup = index ? groupIndex : index;\n            sliderRoot.scrollLeft = 0;\n            scrollTo(selectedGroup);\n          };\n\n          eventStore.add(slide, 'focus', focus, true);\n        }\n\n        function reActivate() {\n          var partialOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n          if (!activated) return;\n          var startIndex = engine.index.get();\n\n          var newOptions = _extends({\n            startIndex: startIndex\n          }, partialOptions);\n\n          deActivate();\n          activate(newOptions);\n        }\n\n        function deActivate() {\n          engine.dragHandler.removeAllEvents();\n          engine.animation.stop();\n          eventStore.removeAll();\n          root.classList.remove(options.draggableClass);\n          container.style.transform = '';\n          slides.forEach(function (s) {\n            return s.style.left = '';\n          });\n        }\n\n        function destroy() {\n          deActivate();\n          activated = false;\n          engine = {};\n          events.dispatch('destroy');\n        }\n\n        function resize() {\n          if (windowWidth === window.innerWidth) return;\n          windowWidth = window.innerWidth;\n          reActivate();\n          events.dispatch('resize');\n        }\n\n        function scrollSnapList() {\n          return engine.indexGroups.map(function (g) {\n            return {\n              slideIndexes: g,\n              slideNodes: g.map(function (i) {\n                return slides[i];\n              })\n            };\n          });\n        }\n\n        function scrollBy(progress, snap) {\n          var distance = engine.scrollProgress.add(progress);\n          engine.scrollBody.useDefaultMass().useDefaultSpeed();\n          engine.scrollTo.distance(distance, snap);\n        }\n\n        function scrollToProgress(progress, snap) {\n          var desired = engine.scrollProgress.set(progress);\n          var distance = engine.scrollTarget.shortcut(desired, 0);\n          engine.scrollBody.useDefaultMass().useDefaultSpeed();\n          engine.scrollTo.distance(distance, snap);\n        }\n\n        function scrollProgress() {\n          var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n          var locationType = target ? 'target' : 'location';\n          var location = engine[locationType].get();\n          return engine.scrollProgress.get(location);\n        }\n\n        function scrollTo(index) {\n          engine.scrollBody.useDefaultMass().useDefaultSpeed();\n          engine.scrollTo.index(index, 0);\n        }\n\n        function scrollNext() {\n          var next = engine.index.clone().add(1);\n          engine.scrollBody.useDefaultMass().useDefaultSpeed();\n          engine.scrollTo.index(next.get(), -1);\n        }\n\n        function scrollPrev() {\n          var prev = engine.index.clone().add(-1);\n          engine.scrollBody.useDefaultMass().useDefaultSpeed();\n          engine.scrollTo.index(prev.get(), 1);\n        }\n\n        function canScrollPrev() {\n          var _engine2 = engine,\n              index = _engine2.index;\n          return options.loop || index.get() !== index.min;\n        }\n\n        function canScrollNext() {\n          var _engine3 = engine,\n              index = _engine3.index;\n          return options.loop || index.get() !== index.max;\n        }\n\n        function selectedScrollSnap() {\n          return engine.index.get();\n        }\n\n        function previousScrollSnap() {\n          return engine.indexPrevious.get();\n        }\n\n        function clickAllowed() {\n          return engine.dragHandler.clickAllowed();\n        }\n\n        function containerNode() {\n          return container;\n        }\n\n        function slideNodes() {\n          return slides;\n        }\n\n        var self = {\n          canScrollNext: canScrollNext,\n          canScrollPrev: canScrollPrev,\n          changeOptions: changeOptions,\n          clickAllowed: clickAllowed,\n          containerNode: containerNode,\n          destroy: destroy,\n          off: off,\n          on: on,\n          previousScrollSnap: previousScrollSnap,\n          scrollBy: scrollBy,\n          scrollNext: scrollNext,\n          scrollPrev: scrollPrev,\n          scrollProgress: scrollProgress,\n          scrollSnapList: scrollSnapList,\n          scrollTo: scrollTo,\n          scrollToProgress: scrollToProgress,\n          selectedScrollSnap: selectedScrollSnap,\n          slideNodes: slideNodes\n        };\n        return Object.freeze(self);\n      }\n\n      exports.EmblaCarousel = EmblaCarousel;\n      exports[\"default\"] = EmblaCarousel; // @ts-ignore\n\n      module.exports = EmblaCarousel;\n      /***/\n    },\n    /* 8 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var alignment_1 = __webpack_require__(9);\n\n      var animation_1 = __webpack_require__(10);\n\n      var counter_1 = __webpack_require__(3);\n\n      var dragHandler_1 = __webpack_require__(11);\n\n      var dragTracker_1 = __webpack_require__(12);\n\n      var limit_1 = __webpack_require__(2);\n\n      var pxToPercent_1 = __webpack_require__(13);\n\n      var scrollBody_1 = __webpack_require__(14);\n\n      var scrollBounds_1 = __webpack_require__(15);\n\n      var scrollContain_1 = __webpack_require__(16);\n\n      var scrollLimit_1 = __webpack_require__(17);\n\n      var scrollLooper_1 = __webpack_require__(18);\n\n      var scrollProgress_1 = __webpack_require__(19);\n\n      var scrollSnap_1 = __webpack_require__(20);\n\n      var scrollTarget_1 = __webpack_require__(21);\n\n      var scrollTo_1 = __webpack_require__(22);\n\n      var slideLooper_1 = __webpack_require__(23);\n\n      var translate_1 = __webpack_require__(24);\n\n      var utils_1 = __webpack_require__(1);\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function Engine(root, container, slides, options, events) {\n        // Options\n        var align = options.align,\n            startIndex = options.startIndex,\n            loop = options.loop,\n            speed = options.speed,\n            dragFree = options.dragFree,\n            slidesToScroll = options.slidesToScroll,\n            containScroll = options.containScroll; // Measurements\n\n        var containerSize = utils_1.rectWidth(container);\n        var pxToPercent = pxToPercent_1.PxToPercent(containerSize);\n        var viewSize = pxToPercent.totalPercent;\n        var slideIndexes = utils_1.arrayKeys(slides);\n        var slideSizes = slides.map(utils_1.rectWidth).map(pxToPercent.measure);\n        var groupedSizes = utils_1.groupArray(slideSizes, slidesToScroll);\n        var snapSizes = groupedSizes.map(function (g) {\n          return g.reduce(function (a, s) {\n            return a + s;\n          });\n        });\n        var snapIndexes = utils_1.arrayKeys(snapSizes);\n        var contentSize = slideSizes.reduce(function (a, s) {\n          return a + s;\n        });\n        var alignment = alignment_1.Alignment({\n          align: align,\n          viewSize: viewSize\n        });\n        var scrollSnap = scrollSnap_1.ScrollSnap({\n          snapSizes: snapSizes,\n          alignment: alignment,\n          loop: loop\n        });\n        var scrollContain = scrollContain_1.ScrollContain({\n          alignment: alignment,\n          contentSize: contentSize,\n          slideIndexes: slideIndexes,\n          slidesToScroll: slidesToScroll,\n          viewSize: viewSize\n        });\n        var contain = !loop && containScroll;\n        var defaultSnaps = snapIndexes.map(scrollSnap.measure);\n        var containedSnaps = scrollContain.snaps(defaultSnaps);\n        var scrollSnaps = contain ? containedSnaps : defaultSnaps; // Index\n\n        var defaultIndexes = utils_1.groupArray(slideIndexes, slidesToScroll);\n        var containedIndexes = scrollContain.indexes(defaultSnaps);\n        var indexMin = 0;\n        var indexMax = scrollSnaps.length - 1;\n        var indexGroups = contain ? containedIndexes : defaultIndexes;\n        var indexSpan = limit_1.Limit({\n          min: indexMin,\n          max: indexMax\n        });\n        var index = counter_1.Counter({\n          limit: indexSpan,\n          start: startIndex,\n          loop: loop\n        });\n        var indexPrevious = index.clone(); // ScrollLimit\n\n        var scrollLimit = scrollLimit_1.ScrollLimit({\n          loop: loop,\n          contentSize: contentSize\n        });\n        var limit = scrollLimit.measure(scrollSnaps); // Draw\n\n        var update = function update() {\n          engine.scrollBody.seek(target).update();\n\n          if (!dragHandler.pointerDown()) {\n            if (!loop) engine.scrollBounds.constrain(target);\n            if (engine.scrollBody.settle(target)) engine.animation.stop();\n          }\n\n          if (loop) {\n            var direction = engine.scrollBody.direction.get();\n            engine.scrollLooper.loop(loopVectors, direction);\n            engine.slideLooper.loop(slides);\n          }\n\n          var settled = engine.scrollBody.settle(target);\n          events.dispatch(settled ? 'settle' : 'scroll');\n          engine.translate.to(engine.scrollBody.location);\n          engine.animation.proceed();\n        }; // Shared\n\n\n        var animation = animation_1.Animation(update);\n        var startLocation = scrollSnaps[index.get()];\n        var location = vector1d_1.Vector1D(startLocation);\n        var target = vector1d_1.Vector1D(startLocation);\n        var loopVectors = [location, target];\n        var scrollBody = scrollBody_1.ScrollBody({\n          location: location,\n          speed: speed,\n          mass: 1\n        });\n        var scrollTarget = scrollTarget_1.ScrollTarget({\n          contentSize: contentSize,\n          index: index,\n          limit: limit,\n          loop: loop,\n          scrollSnaps: scrollSnaps,\n          target: target\n        });\n        var scrollTo = scrollTo_1.ScrollTo({\n          animation: animation,\n          events: events,\n          index: index,\n          indexPrevious: indexPrevious,\n          scrollTarget: scrollTarget,\n          target: target\n        }); // DragHandler\n\n        var dragHandler = dragHandler_1.DragHandler({\n          animation: animation,\n          dragFree: dragFree,\n          dragTracker: dragTracker_1.DragTracker(pxToPercent),\n          element: root,\n          events: events,\n          index: index,\n          limit: limit,\n          location: location,\n          loop: loop,\n          scrollBody: scrollBody,\n          scrollTo: scrollTo,\n          snapSizes: snapSizes,\n          target: target\n        }); // Slider\n\n        var engine = {\n          animation: animation,\n          dragHandler: dragHandler,\n          index: index,\n          indexGroups: indexGroups,\n          indexPrevious: indexPrevious,\n          location: location,\n          scrollBody: scrollBody,\n          scrollBounds: scrollBounds_1.ScrollBounds({\n            animation: animation,\n            limit: limit,\n            location: location,\n            scrollBody: scrollBody\n          }),\n          scrollLooper: scrollLooper_1.ScrollLooper({\n            contentSize: contentSize,\n            limit: limit,\n            location: location,\n            pxToPercent: pxToPercent\n          }),\n          scrollProgress: scrollProgress_1.ScrollProgress({\n            limit: limit,\n            loop: loop,\n            target: target\n          }),\n          scrollTarget: scrollTarget,\n          scrollTo: scrollTo,\n          slideLooper: slideLooper_1.SlideLooper({\n            contentSize: contentSize,\n            location: location,\n            scrollSnaps: scrollSnaps,\n            slideSizes: slideSizes,\n            viewSize: viewSize\n          }),\n          target: target,\n          translate: translate_1.Translate(container)\n        };\n        return Object.freeze(engine);\n      }\n\n      exports.Engine = Engine;\n      /***/\n    },\n    /* 9 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function Alignment(params) {\n        var viewSize = params.viewSize,\n            align = params.align;\n        var alignment = {\n          start: start,\n          center: center,\n          end: end\n        };\n\n        function start() {\n          return 0;\n        }\n\n        function center(n) {\n          return (viewSize - n) / 2;\n        }\n\n        function end(n) {\n          return viewSize - n;\n        }\n\n        function percent() {\n          return viewSize * Number(align);\n        }\n\n        function measure(n) {\n          if (typeof align === 'number') return percent();\n          return alignment[align](n);\n        }\n\n        var self = {\n          measure: measure\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Alignment = Alignment;\n      /***/\n    },\n    /* 10 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function Animation(callback) {\n        var run = requestAnimationFrame.bind(window);\n        var end = cancelAnimationFrame.bind(window);\n        var animationFrame = 0;\n\n        function ifAnimating(active, cb) {\n          return function () {\n            if (active === !!animationFrame) cb();\n          };\n        }\n\n        function start() {\n          animationFrame = run(callback);\n        }\n\n        function stop() {\n          end(animationFrame);\n          animationFrame = 0;\n        }\n\n        var self = {\n          proceed: ifAnimating(true, start),\n          start: ifAnimating(false, start),\n          stop: ifAnimating(true, stop)\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Animation = Animation;\n      /***/\n    },\n    /* 11 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var direction_1 = __webpack_require__(4);\n\n      var eventStore_1 = __webpack_require__(5);\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function DragHandler(params) {\n        var target = params.target,\n            scrollBody = params.scrollBody,\n            dragFree = params.dragFree,\n            animation = params.animation;\n        var element = params.element,\n            dragTracker = params.dragTracker,\n            location = params.location,\n            events = params.events,\n            limit = params.limit;\n        var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n        var startX = vector1d_1.Vector1D(0);\n        var startY = vector1d_1.Vector1D(0);\n        var dragStartLocation = vector1d_1.Vector1D(0);\n        var activationEvents = eventStore_1.EventStore();\n        var interactionEvents = eventStore_1.EventStore();\n        var snapForceBoost = {\n          mouse: 2.5,\n          touch: 3.5\n        };\n        var freeForceBoost = {\n          mouse: 4,\n          touch: 7\n        };\n        var snapSpeed = {\n          mouse: 12,\n          touch: 14\n        };\n        var freeSpeed = {\n          mouse: 6,\n          touch: 5\n        };\n        var dragThreshold = 4;\n        var pointerIsDown = false;\n        var preventScroll = false;\n        var preventClick = false;\n        var isMouse = false;\n\n        function addActivationEvents() {\n          var node = element;\n          activationEvents.add(node, 'touchmove', function () {\n            return undefined;\n          }).add(node, 'touchend', function () {\n            return undefined;\n          }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n        }\n\n        function addInteractionEvents() {\n          var node = !isMouse ? element : document;\n          interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n        }\n\n        function removeAllEvents() {\n          activationEvents.removeAll();\n          interactionEvents.removeAll();\n        }\n\n        function isFocusNode(node) {\n          var name = node.nodeName || '';\n          return focusNodes.indexOf(name) > -1;\n        }\n\n        function movementSpeed() {\n          var speed = dragFree ? freeSpeed : snapSpeed;\n          var type = isMouse ? 'mouse' : 'touch';\n          return speed[type];\n        }\n\n        function dragForceBoost() {\n          var boost = dragFree ? freeForceBoost : snapForceBoost;\n          var type = isMouse ? 'mouse' : 'touch';\n          return boost[type];\n        }\n\n        function seekTargetBy(force) {\n          var scrollTo = params.scrollTo,\n              snapSizes = params.snapSizes,\n              index = params.index;\n          var forceAbs = Math.abs(force);\n          var halfSnap = snapSizes[index.get()] / 2;\n          var reachedLimit = limit.reachedAny(target.get() + force);\n          var seekNext = forceAbs > dragThreshold && forceAbs < halfSnap;\n\n          if (!dragFree && !reachedLimit && seekNext) {\n            var indexDiff = direction_1.Direction(force).get() * -1;\n            var next = index.clone().add(indexDiff);\n            scrollTo.index(next.get(), 0);\n          } else {\n            scrollTo.distance(force, !dragFree);\n          }\n        }\n\n        function down(evt) {\n          isMouse = evt.type === 'mousedown';\n          var diffToTarget = target.get() - location.get();\n          var isMoving = Math.abs(diffToTarget) >= 2;\n          var clearPreventClick = isMouse || !isMoving;\n          var isNotFocusNode = !isFocusNode(evt.target);\n          var preventDefault = isMoving || isMouse && isNotFocusNode;\n          if (isMouse && evt.button !== 0) return;\n          pointerIsDown = true;\n          dragTracker.pointerDown(evt);\n          dragStartLocation.set(target);\n          target.set(location);\n          scrollBody.useDefaultMass().useSpeed(80);\n          addInteractionEvents();\n          animation.start();\n          startX.set(dragTracker.readPoint(evt, 'x'));\n          startY.set(dragTracker.readPoint(evt, 'y'));\n          events.dispatch('dragStart');\n          if (clearPreventClick) preventClick = false;\n          if (preventDefault) evt.preventDefault();\n        }\n\n        function move(evt) {\n          if (!preventScroll && !isMouse) {\n            var X = dragTracker.readPoint(evt, 'x').get();\n            var Y = dragTracker.readPoint(evt, 'y').get();\n            var diffX = Math.abs(X - startX.get());\n            var diffY = Math.abs(Y - startY.get());\n            preventScroll = diffX > diffY;\n            if (!preventScroll && !preventClick) return up();\n          }\n\n          var diff = dragTracker.pointerMove(evt);\n          var reachedLimit = limit.reachedAny(location.get());\n          var resist = !params.loop && reachedLimit ? 2 : 1;\n          if (!preventClick && diff) preventClick = true;\n          target.add(diff / resist);\n          evt.preventDefault();\n        }\n\n        function up() {\n          var force = dragTracker.pointerUp() * dragForceBoost();\n          var diffToTarget = target.get() - dragStartLocation.get();\n          var isMoving = Math.abs(diffToTarget) >= 0.5;\n          if (isMoving && !isMouse) preventClick = true;\n          isMouse = false;\n          preventScroll = false;\n          pointerIsDown = false;\n          interactionEvents.removeAll();\n          scrollBody.useSpeed(movementSpeed());\n          seekTargetBy(force);\n          events.dispatch('dragEnd');\n        }\n\n        function click(evt) {\n          if (preventClick) evt.preventDefault();\n        }\n\n        function clickAllowed() {\n          return !preventClick;\n        }\n\n        function pointerDown() {\n          return pointerIsDown;\n        }\n\n        var self = {\n          addActivationEvents: addActivationEvents,\n          clickAllowed: clickAllowed,\n          pointerDown: pointerDown,\n          removeAllEvents: removeAllEvents\n        };\n        return Object.freeze(self);\n      }\n\n      exports.DragHandler = DragHandler;\n      /***/\n    },\n    /* 12 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function DragTracker(pxToPercent) {\n        var coords = {\n          x: 'clientX',\n          y: 'clientY'\n        };\n        var startDrag = vector1d_1.Vector1D(0);\n        var diffDrag = vector1d_1.Vector1D(0);\n        var lastDrag = vector1d_1.Vector1D(0);\n        var pointValue = vector1d_1.Vector1D(0);\n        var trackInterval = 10;\n        var trackPoints = [];\n        var trackTime = new Date().getTime();\n        var isMouse = false;\n\n        function readPoint(evt, axis) {\n          isMouse = !evt.touches;\n          var c = coords[axis];\n          var value = isMouse ? evt[c] : evt.touches[0][c];\n          return pointValue.set(value);\n        }\n\n        function pointerDown(evt) {\n          var point = readPoint(evt, 'x');\n          startDrag.set(point);\n          lastDrag.set(point);\n          return pxToPercent.measure(startDrag.get());\n        }\n\n        function pointerMove(evt) {\n          var point = readPoint(evt, 'x');\n          var time2 = new Date().getTime();\n          var time1 = trackTime;\n\n          if (time2 - time1 >= trackInterval) {\n            trackPoints.push(point.get());\n            trackTime = time2;\n          }\n\n          diffDrag.set(point).subtract(lastDrag);\n          lastDrag.set(point);\n          return pxToPercent.measure(diffDrag.get());\n        }\n\n        function pointerUp() {\n          var currentPoint = lastDrag.get();\n          var trackLength = isMouse ? 5 : 4;\n          var point = trackPoints.slice(-trackLength).map(function (trackPoint) {\n            return currentPoint - trackPoint;\n          }).sort(function (p1, p2) {\n            return Math.abs(p1) < Math.abs(p2) ? 1 : -1;\n          })[0];\n          lastDrag.set(point || 0);\n          trackPoints = [];\n          return pxToPercent.measure(lastDrag.get());\n        }\n\n        var self = {\n          pointerDown: pointerDown,\n          pointerMove: pointerMove,\n          pointerUp: pointerUp,\n          readPoint: readPoint\n        };\n        return Object.freeze(self);\n      }\n\n      exports.DragTracker = DragTracker;\n      /***/\n    },\n    /* 13 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function PxToPercent(viewInPx) {\n        var totalPercent = 100;\n\n        function measure(n) {\n          return n / viewInPx * totalPercent;\n        }\n\n        var self = {\n          measure: measure,\n          totalPercent: totalPercent\n        };\n        return Object.freeze(self);\n      }\n\n      exports.PxToPercent = PxToPercent;\n      /***/\n    },\n    /* 14 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var direction_1 = __webpack_require__(4);\n\n      var utils_1 = __webpack_require__(1);\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function ScrollBody(params) {\n        var location = params.location,\n            speed = params.speed,\n            mass = params.mass;\n        var roundToTwoDecimals = utils_1.roundToDecimals(2);\n        var velocity = vector1d_1.Vector1D(0);\n        var acceleration = vector1d_1.Vector1D(0);\n        var attraction = vector1d_1.Vector1D(0);\n        var direction = direction_1.Direction(0);\n        var state = {\n          speed: speed,\n          mass: mass\n        };\n\n        function update() {\n          velocity.add(acceleration);\n          location.add(velocity);\n          acceleration.multiply(0);\n        }\n\n        function applyForce(v) {\n          v.divide(state.mass);\n          acceleration.add(v);\n        }\n\n        function seek(v) {\n          attraction.set(v).subtract(location);\n          var magnitude = attraction.get();\n          var m = utils_1.map(magnitude, 0, 100, 0, state.speed);\n          direction.set(attraction);\n          attraction.normalize().multiply(m).subtract(velocity);\n          applyForce(attraction);\n          return self;\n        }\n\n        function settle(v) {\n          var diff = v.get() - location.get();\n          var diffRounded = roundToTwoDecimals(diff);\n          var hasSettled = !diffRounded;\n          if (hasSettled) location.set(v);\n          return hasSettled;\n        }\n\n        function useSpeed(n) {\n          state.speed = n;\n          return self;\n        }\n\n        function useDefaultSpeed() {\n          useSpeed(speed);\n          return self;\n        }\n\n        function useMass(n) {\n          state.mass = n;\n          return self;\n        }\n\n        function useDefaultMass() {\n          useMass(mass);\n          return self;\n        }\n\n        var self = {\n          direction: direction,\n          location: location,\n          seek: seek,\n          settle: settle,\n          update: update,\n          useDefaultMass: useDefaultMass,\n          useDefaultSpeed: useDefaultSpeed,\n          useMass: useMass,\n          useSpeed: useSpeed\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollBody = ScrollBody;\n      /***/\n    },\n    /* 15 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function ScrollBounds(params) {\n        var limit = params.limit,\n            location = params.location,\n            scrollBody = params.scrollBody,\n            animation = params.animation;\n        var min = limit.min,\n            max = limit.max,\n            reachedMin = limit.reachedMin,\n            reachedMax = limit.reachedMax;\n        var tolerance = 50;\n        var timeout = 0;\n\n        function shouldConstrain(v) {\n          if (timeout) return false;\n          if (reachedMin(location.get())) return v.get() !== min;\n          if (reachedMax(location.get())) return v.get() !== max;\n          return false;\n        }\n\n        function constrain(v) {\n          if (!shouldConstrain(v)) return;\n          timeout = window.setTimeout(function () {\n            var constraint = limit.constrain(v.get());\n            v.set(constraint);\n            scrollBody.useSpeed(10).useMass(3);\n            animation.start();\n            timeout = 0;\n          }, tolerance);\n        }\n\n        var self = {\n          constrain: constrain\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollBounds = ScrollBounds;\n      /***/\n    },\n    /* 16 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var limit_1 = __webpack_require__(2);\n\n      var utils_1 = __webpack_require__(1);\n\n      function ScrollContain(params) {\n        var alignment = params.alignment,\n            contentSize = params.contentSize,\n            viewSize = params.viewSize;\n        var slideIndexes = params.slideIndexes,\n            slidesToScroll = params.slidesToScroll;\n        var indexGroups = utils_1.groupArray(slideIndexes, slidesToScroll);\n        var contentExceedsView = contentSize > viewSize;\n        var bounds = limit_1.Limit({\n          min: -contentSize + viewSize,\n          max: 0\n        });\n\n        function groupDuplicates(start, end) {\n          var duplicates = indexGroups.slice(start, end);\n          return duplicates.reduce(function (a, g) {\n            return a.concat(g);\n          }, []);\n        }\n\n        function findDuplicates(scrollSnaps) {\n          var startSnap = scrollSnaps[0];\n          var endSnap = scrollSnaps[scrollSnaps.length - 1];\n          var min = scrollSnaps.lastIndexOf(startSnap) + 1;\n          var max = scrollSnaps.indexOf(endSnap);\n          return limit_1.Limit({\n            min: min,\n            max: max\n          });\n        }\n\n        function indexes(scrollSnaps) {\n          if (!contentExceedsView) return [slideIndexes];\n          var containedSnaps = scrollSnaps.map(bounds.constrain);\n\n          var _findDuplicates = findDuplicates(containedSnaps),\n              min = _findDuplicates.min,\n              max = _findDuplicates.max;\n\n          var start = groupDuplicates(0, min);\n          var middle = indexGroups.slice(min, max);\n          var end = groupDuplicates(max, scrollSnaps.length);\n          return [start].concat(middle.concat([end]));\n        }\n\n        function snaps(scrollSnaps) {\n          if (!contentExceedsView) return [alignment.measure(contentSize)];\n          var containedSnaps = scrollSnaps.map(bounds.constrain);\n\n          var _findDuplicates2 = findDuplicates(containedSnaps),\n              min = _findDuplicates2.min,\n              max = _findDuplicates2.max;\n\n          return containedSnaps.slice(min - 1, max + 1);\n        }\n\n        var self = {\n          indexes: indexes,\n          snaps: snaps\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollContain = ScrollContain;\n      /***/\n    },\n    /* 17 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var limit_1 = __webpack_require__(2);\n\n      function ScrollLimit(params) {\n        var contentSize = params.contentSize,\n            loop = params.loop;\n\n        function measure(scrollSnaps) {\n          var startSnap = scrollSnaps[0];\n          var endSnap = scrollSnaps[scrollSnaps.length - 1];\n          var min = loop ? startSnap - contentSize : endSnap;\n          var max = startSnap;\n          return limit_1.Limit({\n            min: min,\n            max: max\n          });\n        }\n\n        var self = {\n          measure: measure\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollLimit = ScrollLimit;\n      /***/\n    },\n    /* 18 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var limit_1 = __webpack_require__(2);\n\n      function ScrollLooper(params) {\n        var contentSize = params.contentSize,\n            location = params.location,\n            limit = params.limit,\n            pxToPercent = params.pxToPercent;\n        var min = limit.min + pxToPercent.measure(0.1);\n        var max = limit.max + pxToPercent.measure(0.1);\n\n        var _limit_1$Limit = limit_1.Limit({\n          min: min,\n          max: max\n        }),\n            reachedMin = _limit_1$Limit.reachedMin,\n            reachedMax = _limit_1$Limit.reachedMax;\n\n        function shouldLoop(direction) {\n          if (direction === 1) return reachedMax(location.get());\n          if (direction === -1) return reachedMin(location.get());\n          return false;\n        }\n\n        function loop(vectors, direction) {\n          if (!shouldLoop(direction)) return;\n          var loopDistance = contentSize * (direction * -1);\n          vectors.forEach(function (v) {\n            return v.add(loopDistance);\n          });\n        }\n\n        var self = {\n          loop: loop\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollLooper = ScrollLooper;\n      /***/\n    },\n    /* 19 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function ScrollProgress(params) {\n        var limit = params.limit,\n            loop = params.loop,\n            target = params.target;\n        var min = limit.min,\n            max = limit.max,\n            reachedMin = limit.reachedMin,\n            reachedMax = limit.reachedMax;\n        var scrollLength = min - max;\n\n        function withinBounds(n) {\n          var desiredTarget = target.get() + n;\n          if (reachedMax(desiredTarget)) return max - target.get();\n          if (reachedMin(desiredTarget)) return min - target.get();\n          return n;\n        }\n\n        function get(n) {\n          var currentLocation = n - max;\n          return currentLocation / scrollLength;\n        }\n\n        function set(n) {\n          var progressToTarget = n - get(target.get());\n          return withinBounds(add(progressToTarget));\n        }\n\n        function add(n) {\n          var distance = scrollLength * n;\n          return loop ? distance : withinBounds(distance);\n        }\n\n        var self = {\n          get: get,\n          set: set,\n          add: add\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollProgress = ScrollProgress;\n      /***/\n    },\n    /* 20 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var counter_1 = __webpack_require__(3);\n\n      var limit_1 = __webpack_require__(2);\n\n      function ScrollSnap(params) {\n        var snapSizes = params.snapSizes,\n            alignment = params.alignment,\n            loop = params.loop;\n        var alignments = snapSizes.map(alignment.measure);\n        var distancesBetween = distancesBetweenScrollSnaps();\n\n        function distancesBetweenScrollSnaps() {\n          var limit = limit_1.Limit({\n            min: 0,\n            max: snapSizes.length - 1\n          });\n          var counter = counter_1.Counter({\n            limit: limit,\n            start: 0,\n            loop: loop\n          });\n          return snapSizes.map(function (size, index) {\n            var next = counter.set(index + 1).get();\n            return size + alignments[index] - alignments[next];\n          });\n        }\n\n        function measure(index) {\n          var sizes = distancesBetween.slice(0, index);\n          return sizes.reduce(function (a, s) {\n            return a - s;\n          }, alignments[0]);\n        }\n\n        var self = {\n          measure: measure\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollSnap = ScrollSnap;\n      /***/\n    },\n    /* 21 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function ScrollTarget(params) {\n        var loop = params.loop,\n            limit = params.limit,\n            scrollSnaps = params.scrollSnaps,\n            contentSize = params.contentSize;\n        var reachedMin = limit.reachedMin,\n            reachedMax = limit.reachedMax,\n            reachedAny = limit.reachedAny;\n\n        function minDistance(d1, d2) {\n          return Math.abs(d1) < Math.abs(d2) ? d1 : d2;\n        }\n\n        function findTargetSnap(target) {\n          while (reachedMin(target)) {\n            target += contentSize;\n          }\n\n          while (reachedMax(target)) {\n            target -= contentSize;\n          }\n\n          var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n            return scrollSnap - target;\n          }).map(function (diffToSnap) {\n            return shortcut(diffToSnap, 0);\n          }).map(function (diff, i) {\n            return {\n              diff: diff,\n              index: i\n            };\n          }).sort(function (d1, d2) {\n            return Math.abs(d1.diff) - Math.abs(d2.diff);\n          });\n          var index = ascDiffsToSnaps[0].index;\n          return {\n            index: index,\n            distance: target\n          };\n        }\n\n        function shortcut(target, direction) {\n          var t1 = target;\n          var t2 = target + contentSize;\n          var t3 = target - contentSize;\n          if (!loop) return t1;\n          if (!direction) return minDistance(minDistance(t1, t2), t3);\n          var shortest = minDistance(t1, direction === 1 ? t2 : t3);\n          return Math.abs(shortest) * direction;\n        }\n\n        function findTargetIndex(target, index) {\n          var reachedBound = !loop && reachedAny(target);\n          if (!reachedBound) return index;\n          var _params$index = params.index,\n              min = _params$index.min,\n              max = _params$index.max;\n          return reachedMax(target) ? min : max;\n        }\n\n        function byIndex(index, direction) {\n          var diffToSnap = scrollSnaps[index] - params.target.get();\n          var distance = shortcut(diffToSnap, direction);\n          return {\n            index: index,\n            distance: distance\n          };\n        }\n\n        function byDistance(distance, snap) {\n          var target = params.target.get() + distance;\n          var targetSnap = findTargetSnap(target);\n          var targetIndex = findTargetIndex(target, targetSnap.index);\n          var index = snap && !distance ? params.index.get() : targetIndex;\n          var reachedBound = !loop && reachedAny(target);\n          if (!snap || reachedBound) return {\n            index: index,\n            distance: distance\n          };\n          var diffToSnap = scrollSnaps[index] - targetSnap.distance;\n          var snapDistance = distance + shortcut(diffToSnap, 0);\n          return {\n            index: index,\n            distance: snapDistance\n          };\n        }\n\n        var self = {\n          byDistance: byDistance,\n          byIndex: byIndex,\n          shortcut: shortcut\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollTarget = ScrollTarget;\n      /***/\n    },\n    /* 22 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function ScrollTo(params) {\n        var indexCurrent = params.index,\n            scrollTarget = params.scrollTarget,\n            animation = params.animation;\n        var indexPrevious = params.indexPrevious,\n            events = params.events,\n            targetDistance = params.target;\n\n        function scrollTo(target) {\n          var distanceDiff = target.distance;\n          var indexDiff = target.index !== indexCurrent.get();\n\n          if (distanceDiff) {\n            animation.start();\n            targetDistance.add(distanceDiff);\n          }\n\n          if (indexDiff) {\n            indexPrevious.set(indexCurrent.get());\n            indexCurrent.set(target.index);\n            events.dispatch('select');\n          }\n        }\n\n        function distance(n, snap) {\n          var target = scrollTarget.byDistance(n, snap);\n          scrollTo(target);\n        }\n\n        function index(n, direction) {\n          var targetIndex = indexCurrent.clone().set(n);\n          var target = scrollTarget.byIndex(targetIndex.get(), direction);\n          scrollTo(target);\n        }\n\n        var self = {\n          distance: distance,\n          index: index\n        };\n        return Object.freeze(self);\n      }\n\n      exports.ScrollTo = ScrollTo;\n      /***/\n    },\n    /* 23 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var utils_1 = __webpack_require__(1);\n\n      var vector1d_1 = __webpack_require__(0);\n\n      function SlideLooper(params) {\n        var contentSize = params.contentSize,\n            viewSize = params.viewSize,\n            slideSizes = params.slideSizes,\n            scrollSnaps = params.scrollSnaps;\n        var ascItems = utils_1.arrayKeys(slideSizes);\n        var descItems = ascItems.slice().reverse();\n        var loopPoints = startPoints().concat(endPoints());\n\n        function subtractItemSizesOf(indexes, from) {\n          return indexes.reduce(function (a, i) {\n            var size = slideSizes[i];\n            return a - size;\n          }, from);\n        }\n\n        function loopItemsIn(sizeOfGap, indexes) {\n          return indexes.reduce(function (a, i) {\n            var gapLeft = subtractItemSizesOf(a, sizeOfGap);\n            return gapLeft > 0 ? a.concat([i]) : a;\n          }, []);\n        }\n\n        function loopStart(sizeOfGap, indexes, from) {\n          return indexes.reduce(function (a, i) {\n            var gapFilled = a + slideSizes[i];\n            return gapFilled < sizeOfGap ? gapFilled : a;\n          }, from);\n        }\n\n        function loopPoint(indexes, from, direction) {\n          var slideCount = ascItems.length - 1;\n          return subtractItemSizesOf(indexes.map(function (i) {\n            return (i + direction) % slideCount;\n          }), from);\n        }\n\n        function loopPointsFor(indexes, from, direction) {\n          var ascIndexes = indexes.slice().sort(function (a, b) {\n            return a - b;\n          });\n          return ascIndexes.map(function (i, j) {\n            var index = i;\n            var initial = contentSize * (!direction ? 0 : -1);\n            var offset = contentSize * (!direction ? 1 : 0);\n            var slidesInSpan = ascIndexes.slice(0, j);\n            var point = loopPoint(slidesInSpan, from, direction);\n            var location = vector1d_1.Vector1D(-1);\n            var target = vector1d_1.Vector1D(0);\n\n            var findTarget = function findTarget(loc) {\n              var t = loc > point ? initial : offset;\n              return target.set(0).set(t);\n            };\n\n            return {\n              point: point,\n              findTarget: findTarget,\n              location: location,\n              index: index\n            };\n          });\n        }\n\n        function startPoints() {\n          var gap = scrollSnaps[0] - 1;\n          var indexes = loopItemsIn(gap, descItems);\n          var start = loopStart(gap, indexes, 0);\n          return loopPointsFor(indexes, start, 1);\n        }\n\n        function endPoints() {\n          var gap = viewSize - scrollSnaps[0] - 1;\n          var indexes = loopItemsIn(gap, ascItems);\n          var start = loopStart(contentSize, ascItems, -viewSize);\n          return loopPointsFor(indexes, -start, 0);\n        }\n\n        function loop(slides) {\n          var parentLocation = params.location;\n          loopPoints.forEach(function (loopTarget) {\n            var findTarget = loopTarget.findTarget,\n                location = loopTarget.location,\n                index = loopTarget.index;\n            var target = findTarget(parentLocation.get());\n\n            if (target.get() !== location.get()) {\n              slides[index].style.left = \"\".concat(target.get(), \"%\");\n              location.set(target);\n            }\n          });\n        }\n\n        var self = {\n          loop: loop,\n          loopPoints: loopPoints\n        };\n        return Object.freeze(self);\n      }\n\n      exports.SlideLooper = SlideLooper;\n      /***/\n    },\n    /* 24 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      var utils_1 = __webpack_require__(1);\n\n      function Translate(node) {\n        var roundToTwoDecimals = utils_1.roundToDecimals(2);\n        var translate = 0;\n\n        function translateX(n) {\n          return \"translate3d(\".concat(n, \"%,0px,0px)\");\n        }\n\n        function to(v) {\n          var target = roundToTwoDecimals(v.get());\n          if (translate === target) return;\n          getComputedStyle(node).transform;\n          node.style.transform = translateX(target);\n          translate = target;\n        }\n\n        var self = {\n          to: to\n        };\n        return Object.freeze(self);\n      }\n\n      exports.Translate = Translate;\n      /***/\n    },\n    /* 25 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n\n      function EventDispatcher() {\n        var listeners = {\n          destroy: [],\n          dragEnd: [],\n          dragStart: [],\n          init: [],\n          resize: [],\n          scroll: [],\n          select: [],\n          settle: []\n        };\n\n        function dispatch(evt) {\n          listeners[evt].forEach(function (e) {\n            return e();\n          });\n          return self;\n        }\n\n        function on(evt, cb) {\n          listeners[evt] = listeners[evt].concat([cb]);\n          return self;\n        }\n\n        function off(evt, cb) {\n          listeners[evt] = listeners[evt].filter(function (e) {\n            return e !== cb;\n          });\n          return self;\n        }\n\n        var self = {\n          dispatch: dispatch,\n          off: off,\n          on: on\n        };\n        return Object.freeze(self);\n      }\n\n      exports.EventDispatcher = EventDispatcher;\n      /***/\n    },\n    /* 26 */\n\n    /***/\n    function (module, exports, __webpack_require__) {\n      \"use strict\";\n\n      Object.defineProperty(exports, \"__esModule\", {\n        value: true\n      });\n      exports.defaultOptions = Object.freeze({\n        align: 'center',\n        containScroll: false,\n        containerSelector: '*',\n        dragFree: false,\n        draggable: true,\n        draggableClass: 'is-draggable',\n        draggingClass: 'is-dragging',\n        loop: false,\n        selectedClass: 'is-selected',\n        slidesToScroll: 1,\n        speed: 10,\n        startIndex: 0\n      });\n      /***/\n    }\n    /******/\n    ])\n  );\n});","map":null,"metadata":{},"sourceType":"script"}